## 类型擦除的影响&桥接方法

有时，类型擦除技术会引起你以前没有遇见过的问题。下面的例子说明了这个问题是怎么发生的。这个例子说明了编译器在类型擦除过程中有时会创建一个合成的方法，称为桥接方法(Bridge Method)。

请看下面两个类定义：

```
public class Node<T> {
	public T data;
	
	pubic Node(T data) {
		this.data = data;
	}
	
	public void setData(T data) {
		System.out.println("Node.setData");
		this.data = data;
	}
}


public class MyNode extends Node<Integer> {
	public MyNode(Integer data) {
			super(data);
	}
	
	public void setData(Integer data) {
		System.out.println("MyNode.setData");
		super.setData(data);
	}
}

```

现在考虑如下代码：

```
MyNode mn = new MyNode(5);
Node n = mn; // a raw type - compile throws an unchecked warning
n.setData("hello");
Integer x = mn.data;

```

类型擦除之后，这段代码变为：

```
MyNode mn = new MyNode(5);
Node n = (MyNode)mn; 
n.setData("hello");
Integer x = (Integer)mn.data; // causes a ClassCastException to be thrown

```

当执行上述代码时，发生了下面的几个过程：

* n.setData("hello"); 执行了MyNode对象的方法setData(Object)。
* 在setData(Object)方法的内部，引用变量n指向的MyNode的实例的data域被赋值为一个String
* 同样，mn指向的MyNode的同一个实例，可以访问data域，并且期望data域是个Integer类型(因为MyNode声明的时候，有继承自Node<Integer>)
* java编译器在执行类型擦除的时候，加入了一个强制类型转换，运行时，在试图将一个String转换成一个Integer的时候，引起了运行时错误。


### Bridge Methods

当编译一个继承了泛型类或实现了泛型接口的类或者接口时，编译器在执行类型擦除的过程中，可能会创建一个合成的方法--称为桥接方法。通常你并不需要关心桥接方法，因为它是自动生成的，但是如果在堆栈轨迹中出现了桥接方法，你也许会感觉迷惑。

编译器执行类型擦除之后，Node类和MyNode类会变成如下：

```
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}


public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}

```

类型擦除之后，方法签名变了。Node的setData方法变成了setData(Object),而MyNode的方法变成了setData(Integer)。因此，MyNode的setData(Integer)方法没有override父类的setData(Object)方法。


为了解决这个问题，在类型擦除后仍保留多态特性，java编译器会自动生成一个桥接方法来保证子类像预期那样工作。对于MyNode类，编译器为setData方法生成如下的桥接方法：

```
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}

```


正如你所看到的，在类型擦除之后，桥接方法，跟Node类的setData方法有同样的签名，委派给了MyNode的setData(Integer)方法。




















































