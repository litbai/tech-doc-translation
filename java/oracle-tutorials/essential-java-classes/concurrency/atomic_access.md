### Atomic Access

在程序中，一个原子动作指的是有效的一次性发生的动作。一个原子动作执行过程中不能停止，它要么全都执行，要么根本不执行。在具备原子性的动作完成之前，它的中间结果没有任何副作用，是不可见的。

我们之前遇到的自增表达式，例如c++，不是一个原子的动作。任何一个简单的表达式都可以定义一个复杂的动作，这个动作可以被分解为多个其他简单动作。但是，下面的动作一定是原子的：

* 对引用数据类型和绝大部分基本数据类型(除了long和double之外的)的读和写是原子的

* 对volatile变量(包括long和double类型的变量)的读和写是原子的


原子操作不可能交叉执行，因为使用他们时不必担心线程干扰的风险。但是，它不能杜绝对同步原子操作的需求，因为现在仍然可能发生内存一致性错误。使用volatile变量可以减少发生内存一致性错误的风险，因为对volatile变量的写操作，自动建立了与后续对该变量的读操作的一个happens-before关系。这表示，一个线程对volatile变量的改变，对其他线程永远是可见的。而且，它还表明当一个线程读取一个volatile变量时，它不仅仅能看到volatile变量的最新值，而且可以看到导致volatile变量发生改变的这段代码的副作用。

使用简单的原子变量访问比使用同步代码更具效率，但是需要开发者更加小心，以避免内存一致性错误。这种额外的付出是否值得，则取决于应用的复杂度。

java.util.concurrent包中的一些类提供了不依赖synchronization的原子方法。我们将会在high levelconcurrency objects一章进行介绍。























