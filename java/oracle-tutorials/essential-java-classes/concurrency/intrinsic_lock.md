### Intrinsic Locks and Synchronization


同步是建立在一个对象的内部实体上的，这个实体称为内部锁或者监视器锁(API中通常称监视器锁为monitor)。内部锁在同步的两个方面都扮演着重要的角色：强制性排外的访问对象的状态和建立对可见性必不可少的happens-before关系。


每一个对象都有一个与之关联的内部锁。通常，一个线程如果想要排外且持续的访问一个对象的域，那么这个线程必须首先获取这个对象的内部锁，访问完之后再释放这个锁。一个对象在获得锁到释放锁这个阶段，被称为拥有内部锁(own intrinsic lock)。只要一个线程拥有一个内部锁，其他线程都不可以获得相同的锁--这些线程在请求获得锁时会阻塞。

当一个线程释放一个对象的内部锁时，这个释放动作就和后续的获取锁动作之间建立了一个happens-before关系。


### Locks in Synchronized Methods

当一个线程调用一个同步方法时，它自动获取了调用这个方法的对象的内部锁，当方法return时，它会释放这个内部锁。如果在方法调用过程中发升了异常，导致方法退出，这个内部锁也将被释放。


你可以好奇当调用一个静态的同步方法时发生了什么，因为静态方法不与某个对象关联，它与类关联。在这种情况下，线程获得了与这个类对应的Class对象的内部锁。因此，访问受锁控制的静态域和实例域所需要获得的锁是不同的。


### Synchronized Statements

另一种创建同步代码的方式是同步语句。不像同步方法，同步语句必须指定需要提供内部锁的对象:

```
public void addName(String name) {
	synchronized(this) {
		lastName = name;
		nameCount++;
	}
	nameList.add(name);
}

```


在上述示例中，addName方法需要同步的改变lastName和nameCount，但是需要避免对其他对象的方法的同步调用（在同步代码块中调用其他对象的方法可能会引起死锁问题）。如果没有同步语句，那么就必须分两个方法，其中第二个方法声明为非同步的，它做的仅仅是调用nameList.add方法。


同步语句也有助提升并发度。假设，类Mslunch有两个实例域，c1和c2，它们从不会一同使用。对这两个域的更新必须是同步的，但是，当更新c1的时候，没有任何理由不允许更新c2，如果这样的话，则造成了不必要的阻塞，降低了并发度。这时，同步方法就不适用了，我们可以创建两个对象专门来提供锁：

```
public class Mslunch {
	private long c1 = 0;
	private long c2 = 0;
	// 据说这里创建两个空的byte数组，最节省资源
	private Object lock1 = new Object();
	private Object lock2 = new Object();
	
	public void inc1() {
		synchronized(lock1) {
			c1++;
		}
	}
	
	public void inc2() {
		synchronized(lock2) {
			c2++;
		}
	}
	
}

```


注意，使用这种技巧时，要十分的小心。你必须百分百的确定交叉访问这两个域是安全的。


### Reentrant Synchronization


一个线程不能获取另一个线程已经拥有的锁。但是一个线程可以获取它自己已经获取的锁（如果锁不是可重入的，那么同步的递归方法将无法执行）。允许一个线程多次获取同一把锁称为可重入同步。它描述了这样一种场景，当一个同步方法，直接或间接的，调用了另一个同步方法，而且这两个方法需要获取同一个对象的锁。如果没有可重入同步，同步代码则必须要考虑如何避免自己阻塞自己了！




















